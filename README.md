# Система аукционов цифровых товаров

> Масштабируемый бэкенд для многораундовых аукционов цифровых активов. Реализация механики Telegram Gift Auctions.

[![Node.js](https://img.shields.io/badge/Node.js-20+-green.svg)](https://nodejs.org/)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.0+-blue.svg)](https://www.typescriptlang.org/)
[![MongoDB](https://img.shields.io/badge/MongoDB-7.0+-green.svg)](https://www.mongodb.com/)
[![Redis](https://img.shields.io/badge/Redis-7.0+-red.svg)](https://redis.io/)
[![Docker](https://img.shields.io/badge/Docker-Ready-blue.svg)](https://www.docker.com/)

---

## Обзор

Проект представляет собой аукционную платформу с поддержкой высокой конкурентной нагрузки. Архитектура спроектирована для работы в реальном времени с тысячами активных подключений. Основной упор сделан на консистентность финансовых данных и защиту от манипуляций.

### Функциональность

- **Многораундовая система** - распределение лотов по временным этапам.
- **WebSocket обновления** - пуш-уведомления о ставках и статусах без задержек.
- **Механика переноса ставок** - проигравшие ставки автоматически переходят в следующий раунд.
- **Защита от снайпинга** - динамическое продление раунда при активности на последних секундах.
- **Атомарность** - операции с балансами выполняются транзакционно, исключая гонки данных.
- **Производительность** - Redis Sorted Sets для сортировки ставок (O(log N)).

---

## Механика работы

Система воспроизводит модель Telegram Gift Auctions. Это не стандартный аукцион "первой цены", а многоэтапный процесс.

### 1. Распределение по раундам

Лоты продаются не единовременно, а частями. Это поддерживает интерес к аукциону на протяжении всего времени проведения.

Параметры раунда:
- Фиксированное время завершения (по умолчанию 2 минуты).
- Ограниченное количество победителей в каждом раунде.

```
Пример: 15 лотов
├── Раунд 1: 3 победителя
├── Раунд 2: 3 победителя
├── ...
└── Раунд 5: 3 победителя (финал)
```

### 2. Перенос ставок

Ключевая особенность логики. Если участник не попал в топ победителей текущего раунда, его ставка не сгорает и не возвращается сразу. Она переносится в следующий раунд.

Алгоритм:
1. Раунд завершается.
2. Топ-N участников получают лоты, средства списываются.
3. Остальные участники автоматически переходят в следующий раунд с текущей суммой ставки.
4. В новом раунде можно увеличить ставку, доплатив разницу.

Это снижает порог входа для продолжения участия и удерживает ликвидность в аукционе.

### 3. Anti-Sniping

Для борьбы с ботами, делающими ставки в последние миллисекунды, реализовано продление времени ("soft close").

Логика:
```typescript
// Если ставка сделана менее чем за 30 секунд до конца
if (timeUntilEnd <= 30_000) {
  roundEndTime += 30_000; // Продление раунда
}
```

Конфигурация через переменные окружения позволяет настроить окно детекции и время продления.

---

## Архитектура

### Компоненты

```
┌─────────────┐       ┌─────────────┐
│   Web UI    │ <───> │   Backend   │
└─────────────┘  WS   └──────┬──────┘
                             │
          ┌──────────────────┴──────────────────┐
          │                                     │
    ┌─────▼─────┐                         ┌─────▼─────┐
    │  MongoDB  │                         │   Redis   │
    │ (Данные)  │                         │  (Кэш)    │
    └───────────┘                         └───────────┘
```

### Выбор Redis для лидербордов

Сортировка большого массива ставок в MongoDB ресурсоемка (O(N log N)). Redis Sorted Sets (ZSET) решают эту задачу эффективнее.

Сравнение производительности (1000 ставок):
- **MongoDB**: ~50мс
- **Redis**: ~1мс (O(log N))

Это критически важно для обработки пиковых нагрузок в конце раундов.

### Финансовые транзакции

Используется паттерн двухфазной блокировки средств для предотвращения double-spending.

1. **Lock**: Сумма ставки замораживается (`frozenFunds`).
2. **Commit/Rollback**: При победе средства списываются, при проигрыше в финале - размораживаются.

При повышении ставки блокируется только разница между новой и старой суммой.

---

## Запуск

Требуется Docker и Docker Compose.

```bash
# Сборка и запуск контейнеров
docker compose up -d --build

# Генерация тестовых данных (пользователи, аукционы)
docker compose exec app npm run seed:prod

# Запуск нагрузочного тестирования
docker compose exec app npm run load-test:prod
```

Сервисы будут доступны по адресам:
- **UI**: http://localhost:3000
- **API**: http://localhost:3000/api/auctions

---

## Тестирование

Проект содержит встроенные сценарии для проверки стабильности системы.

Запуск тестов:
```bash
docker compose exec app npm run load-test:prod
```

Сценарии:
1. **Concurrency** - 50 параллельных запросов. Проверяет обработку гонок.
2. **Stress** - 1000 последовательных ставок. Проверяет утечки и стабильность.
3. **Sniping** - Эмуляция атаки на последних секундах. Проверяет механизм продления.

Ожидаемый результат: `SYSTEM ROBUST`.

---

## API Reference

Основные эндпоинты.

### Получение аукционов
`GET /api/auctions`

### Создание ставки
`POST /api/auctions/:id/bid`

Тело запроса:
```json
{
  "userId": "507f1f77bcf86cd799439011",
  "amount": 1000
}
```

### WebSocket события

Подключение через Socket.IO.

- `newBid` - обновление текущей максимальной ставки.
- `roundExtended` - уведомление о продлении раунда.
- `roundEnd` - завершение раунда, распределение лотов.

---

## Структура проекта

```
src/
├── config/       # Настройки окружения
├── controllers/  # Обработка HTTP запросов
├── models/       # Схемы данных (Mongoose)
├── services/     # Бизнес-логика (Auction, Wallet)
├── server.ts     # Инициализация Express и Socket.IO
└── load-test.ts  # Сценарии нагрузочного тестирования
```

---

## Переменные окружения

| Переменная | Описание | Дефолт |
|------------|----------|--------|
| `PORT` | Порт приложения | 3000 |
| `MONGODB_URI` | Строка подключения Mongo | mongodb://... |
| `REDIS_HOST` | Хост Redis | localhost |
| `ANTI_SNIPE_WINDOW_SECONDS` | Окно срабатывания (сек) | 30 |

---

## Примечания

Реализация фокусируется на корректности работы с данными в условиях конкурентного доступа. Использованы транзакционные подходы там, где это необходимо для финансовой безопасности, и in-memory структуры (Redis) там, где важна скорость реакции интерфейса.

---

**Автор**: @hillblessed
**Лицензия**: ISC
